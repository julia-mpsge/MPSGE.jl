var documenterSearchIndex = {"docs":
[{"location":"overview/demand/#Demand-Blocks","page":"Demand Blocks","title":"Demand Blocks","text":"note: Warning\nDemand blocks will be undergoing significant changes in future releases. We will highlight where changes are likely to occur. The current implementation is stable.\n\nDemand blocks collect the final demands and endowments for each consumer. In MPSGE, demand blocks are created using the @demand macro. ","category":"section"},{"location":"overview/demand/#Final-Demands","page":"Demand Blocks","title":"Final Demands","text":"Each consumer demands goods, defined by the @final_demand macro. It is possible that these goods are the result of a production process, with nestings and elasticities. Because of this you can view final demands as an input from a production block. Currently, this is restricted to a single nest. This is related to Issue #161.","category":"section"},{"location":"overview/demand/#Proposal-to-Change","page":"Demand Blocks","title":"Proposal to Change","text":"Here is an example of a current demand structure with a non-trivial nest:\n\n@demand(M, RA, begin\n    @final_demand(X, Qx)\n    @final_demand(Y, Qy)\n    @final_demand(Z, Qz)\n    @endowment(L, L0)\nend; elasticity = 5)\n\nI propose that we change this to:\n\n@sector(M, X_RA)\n@commodity(M, PX_RA)\n\n@production(M, X_RA, [s=5, t=0], begin\n    @output(PX_RA, Qx+Qy+Qz, t)\n    @input(X, Qx, s)\n    @input(Y, Qy, s)\n    @input(Z, Qz, s)\nend)\n\n@demand(M, RA, PX_RA, begin\n    @endowment(L, L0)\nend)\n\nThere are several advantages to this approach. First, it reduces code duplication between production and demand blocks. Currently, a lot of the code to deal with building cost functions needs to be duplicated between production and demand blocks. Second, it allows for more complex nestings structures in the demand side. Currently, we are limited to a single nest in the demand block, but with this approach, we can have arbitrary nest structures. Third, it makes the model structure more explicit. By defining a sector and commodity for each consumer's demand, it is clear what goods are being demanded and how they are produced. Finally, it simplifies the process of extracting information from the model. With this approach, we can easily extract compensated demands for the consumers goods using existing production block functionality.\n\nOf course, the primary disadvantage is that it requires more code to define the demand structure. There are also concerns that this approach will make some information more difficult to extract. ","category":"section"},{"location":"overview/demand/#Endowments","page":"Demand Blocks","title":"Endowments","text":"Endowments are straightforward, they are defined using the @endowment macro within a demand block. Endowments are simply quantities of goods that a consumer provides to the market at a certain price. You can think of endowments as outputs from the consumer to the market.","category":"section"},{"location":"overview/demand/#Tax-Revenue","page":"Demand Blocks","title":"Tax Revenue","text":"Tax revenue is not explicitly defined in demand blocks. Instead, tax revenue is collected from the taxes applied to netputs in production blocks. Each tax specifies a consumer that receives the tax revenue. This tax revenue is automatically accounted for the income condition.","category":"section"},{"location":"Tutorials/intermediate_examples/M22/#Closed-2\\times2-Economy-with-Intermediate-Inputs-and-Nesting","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Closed 2times2 Economy with Intermediate Inputs and Nesting","text":"This model is available in a notebook file here.\n\nConsider the following social accounting matrix (SAM). \n\nMarkets X Y W CONS\nPX 120 -20 -100 \nPY -20 120 -100 \nPW   200 -200\nPL -40 -60  100\nPK -60 -40  100\n\nWe are going to use this matrix to construct a simple CES nesting structure that permits the modeler to specify different elasticities of substitution between different groups of inputs.\n\nWhile the SAM contains the data to build the model, it doesn't specify any structure. To  do this we use a tree diagram. For this model we will have four trees: X, Y, W, CONS.\n\n(Image: Specific Model Description)\n\nThese should be self explanatory, but we'll detail the X tree. First, X has an associated  elasticity of substitution s=sigma and elasticity of substitution t=0. There is only one output, PX with quantity 120. PY, PL, and PK are inputs, but we are nesting PL and  PK under the shadow sector va, this is also referred to as a nest. The va=1 specifies  the elasticity of substitution on the  inputs of va. Finally, we are going to impose a tax on PL and PK, taxes require a consumer in this case there is only one, CONS. \n\nThe CONS tree is similar, consumers have demands and endowments. In this case, CONS demands 200 units of PW and endows both PL and PK 100 units.\n\nUsing this type of diagram trivializes the implementation of a model into MPSGE. The language of MPSGE is directly tied to these trees, as we will see.","category":"section"},{"location":"Tutorials/intermediate_examples/M22/#Model-Initialization","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Model Initialization","text":"First we import MPSGE and initialize the model.\n\nusing MPSGE\n\nM = MPSGEModel()","category":"section"},{"location":"Tutorials/intermediate_examples/M22/#Defining-Variables","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Defining Variables","text":"This model has:\n\nThree sectors X, Y, and W\nFive commodities PX, PY, PW, PL, and PK\nOne consumer CONS\n\nLet's add these to the model.\n\n@sectors(M, begin\n    X\n    Y\n    W\nend)\n\n@commodities(M, begin\n    PX\n    PY\n    PW\n    PL\n    PK\nend)\n\n@consumer(M, CONS)\n\nWe use the plural version of both sector and commodity because we have  multiple of each. Each of these variables has been added to the local  namespace, so we can type X and it will display X. This is useful as we continue to build the model. These can also be accessed directly from the model, M[:X]. ","category":"section"},{"location":"Tutorials/intermediate_examples/M22/#Parameters","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Parameters","text":"In this model we will want a two parameters, tax and σ. This will allow us to apply various shocks without recompiling the model.\n\n@parameters(M, begin\n    tax, 0\n    σ, .5\nend)\n\nThe parameter block requires that you set initial values for each parameter. ","category":"section"},{"location":"Tutorials/intermediate_examples/M22/#Production","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Production","text":"In this model we will have three production blocks, one for each sector. View the full @production documentation.\n\nWe'll detail the X production block as it has the most interesting structure.  Here is the full production block,\n\n@production(M, X, [s = σ, t = 0, va => s = 1], begin\n    @output(PX, 120, t)\n    @input( PY, 20,  s)\n    @input( PL, 40,  va, taxes = [Tax(CONS,tax)])\n    @input( PK, 60,  va, taxes = [Tax(CONS,tax)])\nend)\n\nthere is a lot going on in this, let's break it down piece by piece. The first few pieces, @production(M, X, are self-explanatory, model and  sector. \n\nThis brings us to [s = σ, t = 0, va => s = 1] which defines the nesting structure. There are two top level nests s and t with respective elasticities of σ and 0. Compare this to the other nest, va, which sits under s, this is denoted with va => s and the = 1 sets the elasticity to 1. One thing to notice is that σ is a previously defined parameter. In general, any quantity can be either a number or parameter.\n\nFinally, @input and @output. These must be wrapped in the begin .. end syntax. The syntax of building an output is the same as an input, so we'll describe an  output. The required information is a commodity, quantity, and nest. We have used Julia macro syntax to suppress parentheses and commas, but you could  equivalently defined these as \n\n@output(PX, 120, t)\n\nOutputs have two possible keywords, reference_price and taxes.  reference_price is a simple quantity whereas taxes is an array of Tax objects, as illustrated in the PK input. \n\nThe remaining production blocks are similar,\n\n@production(M, Y, [t = 0, s = .75, va => s = 1], begin \n    @output( PY, 120, t)\n    @input(  PX, 20, s)\n    @input(  PL, 60, va)\n    @input(  PK, 40, va)\nend)\n\n@production(M, W, [t = 0, s = 1], begin\n    @output( PW, 200, t)\n    @input(  PX, 100, s)\n    @input(  PY, 100, s)\nend)","category":"section"},{"location":"Tutorials/intermediate_examples/M22/#Demand","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Demand","text":"Each consumer will have a corresponding demand block. Here is the demand block for CONS\n\n@demand(M, CONS, begin\n    @final_demand(PW, 200)\n    end,begin\n    @endowment(PL, 100)\n    @endowment(PK,100)\nend)\n\nThe first two inputs are the model and the consumer. Then there are two  begin .. end blocks, the first is for final demand and the second is  endowments. This may get improved in the future to be a single block. ","category":"section"},{"location":"Tutorials/intermediate_examples/M22/#Solving-the-Model","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Solving the Model","text":"To solve the model, you call solve! on the model. You can also pass PATH options view keyword arguments. In this case we are testing the  benchmark calibration so we set the cumulative iteration limit to 0.\n\nsolve!(M; cumulative_iteration_limit = 0)\n\nWhile the solver output can be useful, it's more useful to see the values and the marginal values. Any non-zero marginal value should be investigated.  LINK TO MODEL DEBUGGING INFORMATION HERE.\n\ndf_benchmark = generate_report(M)\n\nThis will return a Julia dataframe, which you can manipulate using any dataframe technique. If you plan to manipulate this dataframe, it will be useful to use the DataFrames package\n\nusing DataFrames.jl\n\nYou can also retrieve information using standard JuMP functions, for example\n\nvalue(X)\n\nwill give you the value of X. \n\nWe can solve a counterfactual by changing the value of a parameter. In this  case we'll also fix PW to 1 to pin a specific solution.\n\nfix(PW,1)\nset_value!(tax,.5)\n\nsolve!(M)\ndf = generate_report(M)","category":"section"},{"location":"installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"This guide explains how to install Julia and MPSGE.If you have installation troubles, read the Common installation issues section below.","category":"section"},{"location":"installation/#Install-Julia","page":"Installation Guide","title":"Install Julia","text":"JuMP is a package for Julia. To use JuMP, first download and install Julia.\n\ntip: Tip\nIf you are new to Julia, read our LINK tutorial.","category":"section"},{"location":"installation/#Install-MPSGE","page":"Installation Guide","title":"Install MPSGE","text":"From Julia, MPSGE is installed using the built-in package manager:\n\nimport Pkg\nPkg.add(\"MPSGE\")\n\ntip: Tip\nWe recommend you create a Pkg environment for each project you use MPSGE for, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.\n\nWhen we release a new version of MPSGE, you can update with:\n\nimport Pkg\nPkg.update(\"MPSGE\")","category":"section"},{"location":"installation/#Common-installation-issues","page":"Installation Guide","title":"Common installation issues","text":"tip: Tip\nWhen in doubt, run import Pkg; Pkg.update() to see if updating your packages fixes the issue. Remember you will need to exit Julia and start a new session for the changes to take effect.","category":"section"},{"location":"installation/#Check-the-version-of-your-packages","page":"Installation Guide","title":"Check the version of your packages","text":"Each package is versioned with a three-part number of the form vX.Y.Z. You can check which versions you have installed with import Pkg; Pkg.status().\n\nThis should almost always be the most-recent release. You can check the releases of a package by going to the relevant GitHub page, and navigating to the \"releases\" page. For example, the list of MPSGE releases is available at: LINK HERE.","category":"section"},{"location":"installation/#Unsatisfiable-requirements-detected","page":"Installation Guide","title":"Unsatisfiable requirements detected","text":"Did you get an error like Unsatisfiable requirements detected for package MPSGE? The Pkg documentation has a section on how to understand and manage these conflicts.","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_robinson_crusoe/#1.-Two-Goods","page":"1. Two Goods","title":"1. Two Goods","text":"In this economy, Robinson Crusoe acts as both a producer and consumer. He will produce and consume coconuts and fish. ","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_robinson_crusoe/#MPSGE-Model-Basics","page":"1. Two Goods","title":"MPSGE Model Basics","text":"","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_robinson_crusoe/#Sectors,-Commodities,-and-Consumers","page":"1. Two Goods","title":"Sectors, Commodities, and Consumers","text":"","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_robinson_crusoe/#Extract-Information","page":"1. Two Goods","title":"Extract Information","text":"","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_robinson_crusoe/#Indexed-Version","page":"1. Two Goods","title":"Indexed Version","text":"","category":"section"},{"location":"overview/constraints/#Model-Equations","page":"Model Equations","title":"Model Equations","text":"CGE models have three classes of constraints:\n\nZero Profit - All money earned is allocated.\nMarket Clearance - All goods produced are consumed.\nIncome Balance - All income earned is spent.\n\nMPSGE builds these equations automatically based on the production and demand blocks defined in the model. Before detailing exactly how these equations are built, we need to first discuss compensated demands.","category":"section"},{"location":"overview/constraints/#Compensated-Demand","page":"Model Equations","title":"Compensated Demand","text":"Sectoral profit is given by the difference between total revenue and total cost. Each production block defines the inputs (costs) and outputs (revenues) of a sector. In MPSGE syntax, the profit of a sector is given by:\n\nrevenue_function(X) - cost_function(X)\n\nThe compensated demand is defined for a sector and commodity, it is the derivative of profit with respect to the tax adjusted price. If Pi_X is the profit of sector X and barP_C is the tax adjusted price of commodity C, then the compensated demand, CD_XC, is given by:\n\nCD_XC = fracpartial Pi_Xpartial barP_C\n\nBy Hotelling's Lemma, we can view compensated demand as the \"quantity\" of good C purchased/sold by sector X. To recover the adjusted \"reference quantity\", we need to multiply the compensated demand by the activity level X. The activity level adjusts the compensated demand to reflect changes in sectoral production given a shock to the economy.\n\nnote: GAMS Report Block\nIn GAMS, the report block in MPSGE reports the compensated demand times the sectoral activity level.\n\nFinally, we can compute the total value of good C purchased/sold by sector X by multiplying the adjusted quantity by the price:\n\nCcdot Xcdot CD_XC","category":"section"},{"location":"overview/constraints/#Zero-Profit","page":"Model Equations","title":"Zero Profit","text":"This constraint is self explanatory, each sector's total revenue must equal its total cost. The actual constraint is:\n\n-Pi_X = 0 perp X\n\nThe reason we specify negative profit is that MPSGE uses the PATH Solver which is an oriented solver. You can think of this as PATH using an inequality constraint of the form f(x) geq 0. By specifying negative profit, we ensure the inequality is oriented correctly. ","category":"section"},{"location":"overview/constraints/#Market-Clearance","page":"Model Equations","title":"Market Clearance","text":"This constraint ensures that for each commodity, total supply equals total demand. Luckily, we've already established how to compute supply and demand using compensated demands. For a fixed commodity C, the total supply is the sum over all sectors, X, of Xcdot CD_XC, plus any endowments provided by consumers minus any demands from consumers. The market clearance constraint is therefore:\n\nsum_X Xcdot CD_XC + sum_Hin rm consumers E_HC - sum_Hin rm consumers D_HC = 0 perp C\n\nWhere E_HC is the endowment of good C from consumer H. The term D_HC is the demand of good C from consumer H, defined as\n\nD_HC = fracQ_CQ_Hcdot fracHC\n\nwhere Q_C is the quantity of good C demanded by consumer H and Q_H is the total quantity of all goods demanded by consumer H.","category":"section"},{"location":"overview/constraints/#Income-Balance","page":"Model Equations","title":"Income Balance","text":"The income balance constraint sets the total income of each consumer. The total income is defined to be the sum of endowments plus tax revenue. For a fixed consumer H, the income balance constraint is given by:\n\nH = sum_C E_HC cdot P_C + sum_Sinrm sectors sum_Cinrm commodities tau_SCH cdot C cdot S cdot CD_SC perp H\n\nThe first term is straight forward, it is the total value of endowments provided by consumer H. The second term is the total tax revenue received by consumer H. Here, tau_SCH is the tax rate applied to sector S for commodity C that is paid to consumer H.\n\nnote: Income Balance?\nThis isn't so much of a constraint as it is a definition of the variable H, which is the total income of consumer H. In a way, this is a sub-expression representing total income.","category":"section"},{"location":"overview/optimizations/#Optimizations","page":"Optimizations","title":"Optimizations","text":"This section is going to detail some of the optimizations that MPSGE employs to speed up model construction and solving. This is what sets MPSGE apart from explicitly writing the equivalent model in JuMP.","category":"section"},{"location":"overview/optimizations/#Subexpressions","page":"Optimizations","title":"Subexpressions","text":"The first major optimization is the use of subexpressions to reduce the size of the generated JuMP model. Cost functions can get very large, depending on the nesting and index, and get used multiple times in the model. To avoid multiple evaluations of large expressions, MPSGE stores cost functions as variables in the JuMP model. This significantly reduces the size of the generated model and speeds up solving time as large expressions do not need to be re-evaluated.\n\nnote: PATH Instability\nThe PATH solver may be slightly unstable when there are a large number of subexpressions. We are working on recommendations to mitigate this issue.","category":"section"},{"location":"overview/optimizations/#What-the-Model-stores","page":"Optimizations","title":"What the Model stores","text":"An MPSGE Model stores references to objects to make constructing the constraints faster. Specifically, the model stores the following mappings:\n\nSectors to their production blocks.\nConsumers to their demand blocks.\nCommodities to a list of sectors that produce/consume them.\nCommodities that consumers demand/endow them. \n\nEach of these is designed to make constructing the model equations faster by avoiding searching through all production/demand blocks. For example, consider calculating the market clearance constraint for a commodity. Instead of searching through all production blocks to find which sectors produce/consume the commodity, we can simply look up the list of sectors that produce/consume the commodity in the model's mapping. When first implemented this resulted in a significant speedup for large models.","category":"section"},{"location":"cookbook/taxes/#Taxes","page":"Taxes","title":"Taxes","text":"This page will contain a recipe on adding taxes into a model.","category":"section"},{"location":"Tutorials/basic_examples/m1_vec/#Basic-Vectorized-Example","page":"Basic Vectorized Example","title":"Basic Vectorized Example","text":"","category":"section"},{"location":"overview/introduction/#Overview-of-MPSGE","page":"Overview of MPSGE","title":"Overview of MPSGE","text":"This chapter provides an overview of the MPSGE package. This is going to be a peak behind the scenes of how MPSGE works, what are its main components, and how they interact with each other. It is not necessary to understand all the details in order to use MPSGE, but it may help you get a better understanding of the package and its capabilities.\n\nAt it's core, MPSGE sits on top of JuMP, a powerful modeling language for mathematical optimization in Julia. MPSGE creates the necessary variables and constraints to represent a CGE model in JuMP, and then uses JuMP's solvers to find the equilibrium solution.","category":"section"},{"location":"overview/variables/#MPSGE-Variables","page":"MPSGE Variables","title":"MPSGE Variables","text":"Variables are created in MPSGE using the eponymous macros. Each macro has two versions: a singular version (e.g. @sector) for creating a single variable, and a plural version (e.g. @sectors) for creating multiple variables at once. \n\nVariables can either be scalars (no index) or indexed (with one or more indices). This is handled automatically by the macros based on the input provided. For example, let's create a scalar sector and indexed sector simultaneously using the @sectors macro:\n\n@sectors(model, begin\n    Scalar\n    Indexed[i=I]\nend)\n\nIn this small example, we create two sectors: Scalar, which is a scalar variable, and Indexed, which is indexed over the set I. The macro automatically detects that Indexed has an index and creates it accordingly. We will explore the difference between scalar and indexed variables in more detail later.\n\nWith this basic understanding, let's dive into the different types of variables available in MPSGE and their keyword arguments.","category":"section"},{"location":"overview/variables/#Variable-Types","page":"MPSGE Variables","title":"Variable Types","text":"There are five types of variables in MPSGE:\n\nParameters - @parameter / @parameters\nSectors - @sector / @sectors\nCommodities - @commodity / @commodities\nConsumers - @consumer / @consumers\nAuxiliary Variables - @auxiliary / @auxiliaries\n\nWith the exception of parameters, these variables are constructed identically using their respective macros. Each variable type has its own set of keyword arguments that can be used to customize its behavior. \n\nKeyword arguments are optional and can be provided in any order. They are specified as keyword = value pairs after the required arguments. The keywords available for non-parameter variables are:\n\ndescription::String = \"\": A description of the variable.\nstart::Real = 1.0: The starting value for the variable in the solver. Auxiliary variables default to a starting value of 0.0.\nlower_bound::Real = 0: The lower bound for the variable.\nupper_bound::Real = Inf: The upper bound for the variable. \n\nParameters represent fixed values in the model, such as technology coefficients or policy parameters. Unlike other variables, you must provide a value when constructing a parameter. Model parameters are saved into the model as variables with names so that certain values can be updated without re-defining the whole model. Parameters are commonly used to run counterfactual simulations, where updating their value will alter the solution, but can be used in other ways.\n\n@parameter(model, parameter, value)\n\nHere, value is the fixed value assigned to the parameter. The only keyword argument available for parameters is description::String = \"\", which allows you to provide a description of the parameter.","category":"section"},{"location":"overview/variables/#Scalar-Variables","page":"MPSGE Variables","title":"Scalar Variables","text":"Scalar variables are the primary objects that go into models, in other words when building a model all the variables will be scalars. \n\nA scalar variable stores three pieces of information:\n\nThe model it belongs to\nThe variable name (will have an index if it is part of an indexed variable)\nA description of the variable\nParameters also store their fixed value\n\nOn construction, a scalar variable creates a JuMP variable in the underlying JuMP model with the same name. Most MPSGE operations on variables are wrappers around JuMP operations. For example, adding two MPSGE scalar variables together results in a JuMP expression with JuMP variables. This is largely transparent to the user, because the JuMP variable has the same name as the MPSGE variable. If there is an operation that is not supported by MPSGE, you can always access the underlying JuMP variable using the get_variable function.","category":"section"},{"location":"overview/variables/#Indexed-Variables","page":"MPSGE Variables","title":"Indexed Variables","text":"Indexed variables are collections of scalar variables that are indexed over one or more sets. Each element in the indexed variable is a scalar variable, and can be accessed using its indices. For example, if we construct an indexed sector variable:\n\n@sectors(model, Y[i=I, j=J])\n\nThis creates a collection of sector variables Y[i,j] for each combination of indices i in set I and j in set J. Each Y[i,j] is a scalar variable that can be used in the same way as any other scalar variable.\n\nThe advantage of an MPSGE indexed variable over an array of scalar variables is that indexed variables are designed to print nicely in model descriptions. When printing an indexed variable, MPSGE will show the variable name along with its indices, making it easier to understand the structure of the model. For example, printing the indexed sector variable Y will display Y[i,j], giving the user a clear indication of the variable's indexing. We display the index i, rather than the array I because I doesn't need to be a symbolic set; it could be any iterable collection. For example, how would the following display:\n\n@sectors(model, begin\n    Z[i = 1:10]\n    W[i = filter(x -> x % 2 == 0, 1:10)]\nend)\n\nIndexed variables store the following pieces of information:\n\nThe model it belongs to\nThe variable name (with no indices)\nAn array of scalar variables\nThe indices used to create the variable\nA description of the variable\n\nWhen an indexed variable is first created, it constructs all the scalar variables. Each scalar variable has the name variable_name[index1,index2,...], where index1, index2, etc. are the specific indices for that scalar variable. For example, the scalar variable Y[1,:a] would be created with the name Symbol(\"Y[1,a]\"), or the symbolic representation of the variable name.","category":"section"},{"location":"overview/variables/#Variable-Functions","page":"MPSGE Variables","title":"Variable Functions","text":"Most JuMP functions have been extended to work with MPSGE scalar variables. Several examples:\n\nvalue\nfix\nunfix\nis_fixed\nset_start_value\nstart_value\nlower_bound\nupper_bound\nset_lower_bound\nset_upper_bound\nall_variables\n\nThis list may not be exhaustive, so if you find a JuMP function that does not work with MPSGE variables, please open an issue on the GitHub repository. Additionally, these functions are missing documentation, we plan to work on this in the future. We also welcome contributions from the community!","category":"section"},{"location":"Tutorials/robinson_crusoe/introduction/#Robinson-Crusoe-Introduction","page":"Robinson Crusoe - Introduction","title":"Robinson Crusoe - Introduction","text":"In this section we will consider the Robinson Crusoe Economy. If you are unfamiliar, Robinson Crusoe is a novel in which the titular character is stranded on a deserted island. \n\nThese models will start exceedingly simple and slowly add complexity. The purpose of these models is to provide an introduction to writing a simple model in MPSGE. They are not intended to be an introduction to general CGE modeling. ","category":"section"},{"location":"Tutorials/robinson_crusoe/introduction/#Model-Descriptions","page":"Robinson Crusoe - Introduction","title":"Model Descriptions","text":"The most basic example, 1 producer, 1 consumer, two goods (coconuts and fish)\nAdd leisure\nIntroduce a second producer and consumer","category":"section"},{"location":"Tutorials/getting_started/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"The purpose of these \"Getting Started\" tutorials is to teach new users the basics of Julia, JuMP, and MPSGE.","category":"section"},{"location":"Tutorials/getting_started/introduction/#How-these-tutorials-are-structured","page":"Introduction","title":"How these tutorials are structured","text":"A high-level overview of the structure of this documentation will assist in finding relevant information.\n\nThe \"Getting Started With\" tutorials are designed as basic introductions to Julia, JuMP, and MPSGE. If you are new to Julia, JuMP, or MPSGE these are the places to start. For now, the non-MPSGE bullets point to JuMP documentation. \nGetting started with Julia\nGetting started with JuMP\nGetting Started with MPSGE\nGetting started with sets and indexing\nGetting started with data and plotting\nDebugging Models\nTips for large models","category":"section"},{"location":"Tutorials/getting_started/introduction/#Markusen's-Examples","page":"Introduction","title":"Markusen's Examples","text":"","category":"section"},{"location":"docs/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"docs/#JuMP.set_lower_bound-Tuple{MPSGE.MPSGEScalarVariable, Real}","page":"API Reference","title":"JuMP.set_lower_bound","text":"set_lower_bound(X::MPSGEScalarVariable, val::Real)\n\nSet the lower bound of an MPSGE variable. This is an extension of the JuMP function set_lower_bound.\n\n\n\n\n\n","category":"method"},{"location":"docs/#JuMP.set_start_value-Tuple{MPSGE.MPSGEScalarVariable, Real}","page":"API Reference","title":"JuMP.set_start_value","text":"set_start_value(X::MPSGEScalarVariable, val::Real)\n\nSet the staring value of an MPSGE variable. This is an extension of the JuMP function set_start_value.\n\n\n\n\n\n","category":"method"},{"location":"docs/#JuMP.set_upper_bound-Tuple{MPSGE.MPSGEScalarVariable, Real}","page":"API Reference","title":"JuMP.set_upper_bound","text":"set_upper_bound(X::MPSGEScalarVariable, val::Real)\n\nSet the upper bound of an MPSGE variable. This is an extension of the JuMP function set_upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE._parse_ref_sets-Tuple{Function, Expr}","page":"API Reference","title":"MPSGE._parse_ref_sets","text":"_parse_ref_sets(error_fn::Function, expr::Expr)\n\nCalled by parse_ref_sets to extract the index variables, index sets, and all indices from an expression of the form Y[r, :a, i=I]. \n\nPerforms checks to interpret the expressions.\n\nAdapted from JuMP. \n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE._strip_nest_elasticity-Tuple{Any}","page":"API Reference","title":"MPSGE._strip_nest_elasticity","text":"_strip_nest_elasticity(nest)\n\nStrips the elasticity from a nest expression. Handles either,\n\ns = σ, root nodes\nva => s = σ, child nodes\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE._strip_nest_name-Tuple{Any}","page":"API Reference","title":"MPSGE._strip_nest_name","text":"_strip_nest_name(nest)\n\nStrips the name and parent from a nest expression. Handles either,\n\ns = σ, root nodes (child is s, parent is missing)\nva => s = σ, child nodes (child is va, parent is s)\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.build_name_expr-Tuple{Union{Nothing, Symbol}, Vector, Dict{Symbol, Any}}","page":"API Reference","title":"MPSGE.build_name_expr","text":"build_name_expr(name::Union{Symbol,Nothing}, index_vars::Vector, kwargs::Dict{Symbol,Any})\n\nBuilds an expression that represents the name of a reference set, including the index variables. \n\nAdapted from JuMP, however the JuMP version returns a String where as this returns a usuable object, like a Sector.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.build_nest_and_parent-Tuple{Any, Any, Any}","page":"API Reference","title":"MPSGE.build_nest_and_parent","text":"build_nest_and_parent(nest_arg::Expr, source)\n\nReturn an expression that evaluates to \n\n((Nest, nest base name), (Parent, parent base name))\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.build_string_expr-Tuple{Union{Nothing, Symbol}, Vector, Dict{Symbol, Any}}","page":"API Reference","title":"MPSGE.build_string_expr","text":"build_string_expr(name::Union{Symbol,Nothing}, index_vars::Vector, kwargs::Dict{Symbol,Any})\n\nBuilds a string expression that represents the name of a reference set, including the index variables.\n\nAdapted from the JuMP build_name_expr. \n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.cost_function-Tuple{MPSGE.ScalarProduction}","page":"API Reference","title":"MPSGE.cost_function","text":"cost_function(S::ScalarSector; virtual = false)\ncost_function(S::ScalarSector, nest::Symbol; virtual = false)\n\nReturn a vector of cost functions for the given sector and nest. If nest is  not provided return the cost function for input tree. \n\nnest is the symbol representing the nest. This can also be the name of a  commodity. \n\nIf virtual is true, return the virtual cost functions.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.create_nodes-Tuple{MPSGEModel, Vector{Any}}","page":"API Reference","title":"MPSGE.create_nodes","text":"create_nodes(generated_nodes::Vector{Any})\n\nGiven a vector of generated nodes, create the nodes and two required trees.\n\nReturns\n\n(nodes::Dict{Symbol, MPSGE.Node}, root_nodes::Vector{MPSGE.Node})\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.extract_scalars-Tuple{MPSGE.MPSGEScalarVariable}","page":"API Reference","title":"MPSGE.extract_scalars","text":"extract_scalars\n\nTakes a variable and extracts it the sub-variables. \n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.generate_report-Tuple{MPSGEModel}","page":"API Reference","title":"MPSGE.generate_report","text":"generate_report(M::MPSGEModel)\n\nReturns a dataframe with three columns, the variable, the value and the margin.  The product of the value and the marge should be zero, if not the model has a  specification error.\n\nThis function is useful for debugging models that fail a calibrated benchmark.  If the model fails the benchmark, look for non-zero margins in this report, as  they will reveal the error.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.parse_mpsge_ref_sets-Tuple{Function, Any, Any, Any, Expr}","page":"API Reference","title":"MPSGE.parse_mpsge_ref_sets","text":"parse_mpsge_ref_sets(error_fn::Function, index_vars, index_sets, all_indices, arg::Expr)\n\nBuilds the three vectors index_vars, index_sets, and all_indices from an expression arg that is part of a reference set. \n\nExpressions of the form i=S, i∈S, and i in S are interpreted as index variables, and will set up variables to create an indexed object.\n\nOtherwise expressions are escaped and treated as scalars.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.parse_netput-Tuple{Function, Any, DataType}","page":"API Reference","title":"MPSGE.parse_netput","text":"parse_netput(error_fn::Function, netput_arg::Any)\n\nMain code that goes in the macro\n\nReturn\n\n(netput, parent nest)\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.parse_ref_sets-Tuple{Function, Expr}","page":"API Reference","title":"MPSGE.parse_ref_sets","text":"parse_ref_sets(error_fn::Function, expr::Expr)\n\nGiven an expression of the form Y[r, :a, i=I] extract four components:\n\nname: the name of the reference set, in this case Y.\nindex_vars: a vector of index variables, in this case [:i]. In this case, only  i is an index variable, while r and :a are not as they do not have and =.\nindices: an expression representing the Cartesian product of the index sets,  in this example it's only I. \nall_indices: a vector of all indices, in this case [:r, :(:a), :i].\n\nThis is used in macros.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.production_sectors-Tuple{MPSGEModel}","page":"API Reference","title":"MPSGE.production_sectors","text":"production_sectors(m::MPSGEModel)\n\nReturn all sectors that have a corresponding production block.  These are coming from a dictionary, so order is not guaranteed.\n\nThis is primarily used when generating constraints.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.revenue_function-Tuple{MPSGE.ScalarProduction}","page":"API Reference","title":"MPSGE.revenue_function","text":"revenue_function(S::ScalarSector; virtual = false)    \nrevenue_function(S::ScalarSector, nest::Symbol; virtual = false)\n\nReturn a vector of revenue functions for the given sector and nest. If nest is  not provided return the revenue function for input tree. \n\nnest is the symbol representing the nest. This can also be the name of a  commodity. \n\nIf virtual is true, return the virtual revenue functions.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.sectors-Tuple{Commodity}","page":"API Reference","title":"MPSGE.sectors","text":"sectors(C::Commodity)\n\nReturn only the sectors that have the input commodity in their production block. \n\nThis is an optimization in building the model as the structure is very sparse  iterating over all sectors is expensive.\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.sectors-Tuple{MPSGEModel}","page":"API Reference","title":"MPSGE.sectors","text":"sectors(m::MPSGEModel)\n\nReturn all sectors in a model\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.solve!-Tuple{MPSGE.AbstractMPSGEModel}","page":"API Reference","title":"MPSGE.solve!","text":"solve!(m::abstract_mpsge_model; keywords)\nFunction to solve the model. Triggers the build if the model hasn't been built yet.\n\nExample\n\njulia> solve!(m, cumulative_iteration_limit=0)\n\n\n\n\n\n","category":"method"},{"location":"docs/#MPSGE.@auxiliaries-Tuple{Any, Any}","page":"API Reference","title":"MPSGE.@auxiliaries","text":"@auxiliaries(model, args...)\n\nAdds multiple @auxiliary to a model. \n\nThe model must be the first argument, and multiple auxiliaries can be added in a  begin ... end block, one auxiliary per line. \n\nExample\n\njulia> M = MPSGEModel()\n\njulia> I = [:a,:b]\n\njulia> @auxiliaries(M, begin\n            X[i=I]\n            Y[i=I,j=I], (description = \"This is an indexed variable\")\n            Z, (description = \"Scalar variable\")\n        end)\n\nnote: Note\nKeywords must be contained in parentheses as in the example above. \n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@auxiliary-Tuple","page":"API Reference","title":"MPSGE.@auxiliary","text":"@auxiliary(model, X, kwargs...)\n@auxiliary(model, X[I], kwargs...)\n@auxiliary(model, X[i=I], kwargs...)\n\nCreate a auxiliary in the model with name X, index I, and index name i with arguments kwargs.\n\nArguments\n\nmodel: An instance of MPSGEModel.\nThe auxiliary X can be instantiated in a several ways. \nX creates a scalar auxiliary\nIf I is a defined array, then X[I] creates an indexed auxiliary with \nindices given by I.\nIf I is a defined array, then X[i=I]creates an indexed auxiliary with \nindices given by I and variable index named i. \n\nIf you want to create an index auxiliary it is highly recommended to use the syntax  from (3) with better name for i, For example X[goods=I], this will get the  index name to goods which will be displayed when printing the model. For example creating a variable using\n\n@auxiliary(M, X[goods=I], description = \"Auxiliary with indexed variables\")\n\nwill allow the auxiliary to be printed as\n\nX[goods] -- Auxiliary with indexed variables\n\nAdditionally, multi-indexed auxiliaries can be created by using the syntax  X[regions = R, goods = G]. \n\nOptional Arguments\n\ndescription: Set a description on a variable. \nstart: Set the starting value of the variable Default 0.0\nlower_bound: Set the lower bound of the variable. Default -Inf.\nupper_bound: Set the upper bound of the variable. Default Inf.\n\nExamples\n\nusing MPSGE\n\nR = Symbol.(:r, 1:5)\nG = Symbol.(:g, 1:5)\nM = MPSGEModel()\n\n@auxiliary(M, X[region=R, goods=G], description=\"Auxiliary with indexed variables\")\n\nnote: Note\nBy default auxiliary variables start at 0 with no lower or upper bounds. These can be set after variable creating using set_start_value,  set_lower_bound, and set_upper_bound.\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@commodities-Tuple{Any, Any}","page":"API Reference","title":"MPSGE.@commodities","text":"@commodities(model, args...)\n\nAdds multiple @commodity to a model. \n\nThe model must be the first argument, and multiple commodities can be added in a  begin ... end block, one commodity per line. \n\nExample\n\njulia> M = MPSGEModel()\n\njulia> I = [:a,:b]\n\njulia> @commodities(M, begin\n            X[i=I]\n            Y[i=I,j=I], (description = \"This is an indexed variable\")\n            Z, (description = \"Scalar variable\")\n        end)\n\nnote: Note\nKeywords must be contained in parentheses as in the example above. \n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@commodity-Tuple","page":"API Reference","title":"MPSGE.@commodity","text":"@commodity(model, C, kwargs...)\n@commodity(model, C[I], kwargs...)\n@commodity(model, C[i=I], kwargs...)\n\nCreate a commodity in the model with name C, index I, and index name i with arguments kwargs.\n\nArguments\n\nmodel: An instance of MPSGEModel.\nThe commodity C can be instantiated in a several ways. \nC creates a scalar commodity\nIf I is a defined array, then C[I] creates an indexed commodity with \nindices given by I.\nIf I is a defined array, then C[i=I]creates an indexed commodity with \nindices given by I and variable index named i. \n\nIf you want to create an index commodity it is highly recommended to use the syntax  from (3) with better name for i, For example C[goods=I], this will get the  index name to goods which will be displayed when printing the model. For example creating a variable using\n\n@commodity(M, C[goods=I], description = \"Commodity with indexed variables\")\n\nwill allow the commodity to be printed as\n\nC[goods] -- Commodity with indexed variables\n\nAdditionally, multi-indexed commoditys can be created by using the syntax  C[regions = R, goods = G]. \n\nOptional Arguments\n\ndescription: Set a description on a variable. \nstart: Set the starting value of the variable Default 1.0\nlower_bound: Set the lower bound of the variable. Default 0.\nupper_bound: Set the upper bound of the variable. Default Inf.\n\nExamples\n\nusing MPSGE\n\nR = Symbol.(:r, 1:5)\nG = Symbol.(:g, 1:5)\nM = MPSGEModel()\n\n@commodity(M, C[region=R, goods=G], description=\"Commodity with indexed variables\")\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@consumer-Tuple","page":"API Reference","title":"MPSGE.@consumer","text":"@consumer(model, H, kwargs...)\n@consumer(model, H[I], kwargs...)\n@consumer(model, H[i=I], kwargs...)\n\nCreate a consumer in the model with name H, index I, and index name i with arguments kwargs.\n\nArguments\n\nmodel: An instance of MPSGEModel.\nThe consumer H can be instantiated in a several ways. \nH creates a scalar consumer\nIf I is a defined array, then H[I] creates an indexed consumer with \nindices given by I.\nIf I is a defined array, then H[i=I]creates an indexed consumer with \nindices given by I and variable index named i. \n\nIf you want to create an index consumer it is highly recommended to use the syntax  from (3) with better name for i, For example H[goods=I], this will get the  index name to goods which will be displayed when printing the model. For example creating a variable using\n\n@consumer(M, H[goods=I], description = \"Consumer with indexed variables\")\n\nwill allow the consumer to be printed as\n\nH[goods] -- Consumer with indexed variables\n\nAdditionally, multi-indexed consumers can be created by using the syntax  H[regions = R, goods = G]. \n\nOptional Arguments\n\ndescription: Set a description on a variable. \nstart: Set the starting value of the variable Default 1.0\nlower_bound: Set the lower bound of the variable. Default 0.\nupper_bound: Set the upper bound of the variable. Default Inf.\n\nExamples\n\nusing MPSGE\n\nR = Symbol.(:r, 1:5)\nG = Symbol.(:g, 1:5)\nM = MPSGEModel()\n\n@consumer(M, H[region=R, goods=G], description=\"Consumer with indexed variables\")\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@consumers-Tuple{Any, Any}","page":"API Reference","title":"MPSGE.@consumers","text":"@consumers(model, args...)\n\nAdds multiple @consumer to a model. \n\nThe model must be the first argument, and multiple consumers can be added in a  begin ... end block, one consumer per line. \n\nExample\n\njulia> M = MPSGEModel()\n\njulia> I = [:a,:b]\n\njulia> @consumers(M, begin\n            X[i=I]\n            Y[i=I,j=I], (description = \"This is an indexed variable\")\n            Z, (description = \"Scalar variable\")\n        end)\n\nnote: Note\nKeywords must be contained in parentheses as in the example above. \n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@demand-Tuple","page":"API Reference","title":"MPSGE.@demand","text":"@demand(model, comsumer, demand_netputs; elasticity = 1)\n\nDefine a demand for a consumer in the model with given demand_netputs where  the final_demands have an elasticity of substitution elasticity.\n\nconsumer\n\nThe consumer can take the following forms:\n\nX, if X is a scalar consumer.\nX[i=I,j=J,...] if the consumer is indexed. Indexing\nX[i=I, :j] if :j is an element of the second index of X.\nX[i=I, j] if j is defined outside the demand block, for example in a for loop.\n\nFor an indexed consumer it is required that an index is provided when iterating over an array. For example, \n\njulia> I = [:a,:b]\n\njulia> @consumer(M, X[i=I])\n\njulia> @demand(M, X[I], ...) # This is not allowed and will error.\n\njulia> @demand(M, X[i=I], ...) # This is required behavior.\n\njulia>  for i in I\n            @demand(M, X[i], ...) # This is allowed.\n        end\n\ndemand_netputs\n\nA demand netput is either a @final_demand or an @endowment. The netputs get wrapped in a begin ... end block and each netput must be on its own line. For examples creating netputs, see the netput documentation and the examples below.\n\nNetputs can use indices initialized in the consumer, but can not use them as a new index. For example, if we have X[i=I] in the demand block, we can use @final_demand(PX[i],...) but not @final_demand(PX[i=I],...). The latter will error.\n\nExamples\n\nWe demonstrate three ways to define a demand block. \n\njulia> M = MPSGEModel();\n\njulia> I = [:a,:b]\n\njulia> @parameters(M, begin\n            elas[i=I,j=J], 4\n            T[i=I], .1\n        end)\n\njulia> @commodities(M, begin\n            PX\n            PY\n            PL[i=I]\n            PK\n        end);\n\njulia> @consumers(M, begin\n            X\n            Y[i=I, j=J]\n            Z[i=I]\n        end);\n\njulia> @demand(M, X, begin\n            @final_demand(PX, 10, t)\n            @endowment(PL, 5, s)\n            @endowment(PK, 5, s)\n        end);\n\njulia> @demand(M, Y[i=I,j=J], [s=2, t=1, begin\n            @final_demand(PY, 15, t, reference_price = 2)\n            @endowment(PX, 3, s)\n            @endowment(PL[ii=I], 4, va[ii])\n            @endowment(PK, 6, va[i])\n        end, elasticity = 2);\n\njulia> for i in I\n            @demand(M, Z[i], begin\n                @final_demand(PK, 20, t)\n                @endowment(PL[i], 2, s)\n            end)\n        end\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@endowment-Tuple","page":"API Reference","title":"MPSGE.@endowment","text":"@endowment(commodity, quantity, nest, kwargs...)\n\nThis macro is soley used within a @demand block to define the endowments  for a consumer. \n\nRequired Arguments\n\ncommodity - A commodity. This can either be a scalar C or indexed C[i=R]. \nquantity - Either a number or expression. \n\nExamples\n\n@endowment(C, 1)\n@endowment(C[i=R], 1)\n@endowment(C[i=R], quantity[i])\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@final_demand-Tuple","page":"API Reference","title":"MPSGE.@final_demand","text":"@final_demand(commodity, quantity, nest, kwargs...)\n\nThis macro is soley used within a @demand block to define the final demands  for a consumer. \n\nRequired Arguments\n\ncommodity - A commodity. This can either be a scalar C or indexed C[i=R]. \nquantity - Either a number or expression. \n\nKeyword Arguments\n\nreference_price=1 Set the reference price of a commodity.\n\nExamples\n\n@final_demand(C, 1)\n@final_demand(C[i=R], 1)\n@final_demand(C[i=R], quantity[i])\n@final_demand(C[i=R], quantity[i], reference_price = price[i])\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@input-Tuple","page":"API Reference","title":"MPSGE.@input","text":"@input(commodity, quantity, nest, kwargs...)\n\nThis macro is soley used within a @production block to define the inputs  for a sector. \n\nRequired Arguments\n\ncommodity - A commodity. This can either be a scalar C or indexed C[i=R]. \nquantity - Either a number or expression. \nnest - The parent nest of the input. \n\nKeyword Arguments\n\ntaxes associate a tax to the commodity. The syntax    taxes = [Tax(RA, .1), Tax(GOVT, .3)] defines two taxes, one associated the    consumer RA and another with GOVT. In this example the values are fixed,    but they can also be parameters.\nreference_price=1 Set the reference price of a commodity.\n\nExamples\n\n@input(C, 1, nest, taxes = [Tax(RA, .1), Tax(GOVT, .3)])\n@input(C[i=R], 1, nest)\n@input(C[i=R], quantity[i], nest[i])\n@input(C[i=R], quantity[i], nest[i], reference_price = price[i])\n@input(C[i=R], quantity[i], nest[i], taxes = [Tax(RA, tax[i]), Tax(GOVT, .5)])\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@output-Tuple","page":"API Reference","title":"MPSGE.@output","text":"@output(commodity, quantity, nest, kwargs...)\n\nThis macro is soley used within a @production block to define the outputs  for a sector. \n\nRequired Arguments\n\ncommodity - A commodity. This can either be a scalar C or indexed C[i=R]. \nquantity - Either a number or expression. \nnest - The parent nest of the output. \n\nKeyword Arguments\n\ntaxes associate a tax to the commodity. The syntax    taxes = [Tax(RA, .1), Tax(GOVT, .3)] defines two taxes, one associated the    consumer RA and another with GOVT. In this example the values are fixed,    but they can also be parameters.\nreference_price=1 Set the reference price of a commodity.\n\nExamples\n\n@output(C, 1, nest, taxes = [Tax(RA, .1), Tax(GOVT, .3)])\n@output(C[i=R], 1, nest)\n@output(C[i=R], quantity[i], nest[i])\n@output(C[i=R], quantity[i], nest[i], reference_price = price[i])\n@output(C[i=R], quantity[i], nest[i], taxes = [Tax(RA, tax[i]), Tax(GOVT, .5)])\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@parameter-Tuple","page":"API Reference","title":"MPSGE.@parameter","text":"@parameter(model, expr, value, kwargs...)\n\nAdd a parameter to the model described by expr with initial value value and  keyword arguments kwargs....\n\nRequired Arguments\n\nmodel is the MPSGE model\nexpr an expression that describes the name and index of the parameter. See   the examples below\nvalue The initial value of the parameter. \n\nKeyword Arguments\n\ndescription A string describing the parameter.\n\nExamples\n\nNon-Indexed Parameters\n\nusing MPSGE\n\nM = MPSGEModel()\n\ninitial_value = 10\n\n@parameter(M, X, 1)\n@parameter(M, Y, initial_value, description=\"A parameter\")\n\nIndexed Parameters\n\nusing MPSGE\n\nM = MPSGEModel()\n\nR = 1:5\nS = 1:3\n\none_dimension = Dict(r => 2*r for r in R)\ntwo_dimension = Dict((r,s) => r+s for r in R, s in S)\n\n@parameter(M, X[r=R], 1, description = \"example\") # Index `R` and value 1 with a description\n@parameter(M, Y[R, S], 1) # Indices `R` and `S` and value 1.\n@parameter(M, Z[r=R], one_dimension[r]) # Index `R` and values `one_dimension[r]`.\n@parameter(M, W[r=R, s=S], two_dimension[r, s]) # Indices `R` and `S` and values `two_dimension[r, s]`.\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@parameters-Tuple{Any, Any}","page":"API Reference","title":"MPSGE.@parameters","text":"@parameters(model, args...)\n\nAdds multiple parameters to model at once, in the same fashion as the @parameter macro.\n\nThe model must be the first argument, and multiple parameters can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the parameters that were defined.\n\nExample\n\nusing MPSGE\nmodel = MPSGEModel();\n\n@parameters(model, begin\n           x, 1\n           y[i = 1:2], i, (description = \"y parameter\")\n       end)\n\nnote: Note\nKeyword arguments must be contained within parentheses (refer to the example above).\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@production-Tuple","page":"API Reference","title":"MPSGE.@production","text":"@production(model, sector, nestings, netputs)\n\nDefine a production for the sector in the model with given nestings and netputs. \n\nsector\n\nThe sector can take the following forms:\n\nX, if X is a scalar sector.\nX[i=I,j=J,...] if the sector is indexed. Indexing\nX[i=I, :j] if :j is an element of the second index of X.\nX[i=I, j] if j is defined outside the production block, for example in a for loop.\n\nFor an indexed sector it is required that an index is provided when iterating over an array. For example, \n\njulia> I = [:a,:b]\n\njulia> @sector(M, X[i=I])\n\njulia> @production(M, X[I], ...) # This is not allowed and will error.\n\njulia> @production(M, X[i=I], ...) # This is required behavior.\n\njulia>  for i in I\n            @production(M, X[i], ...) # This is allowed.\n        end\n\nnestings\n\nThis is where the nesting structure is defined and the associated elasticities. At minimum you must declare at least two nests and elasticities, one for the elasticity of substitution (input) and one for the elasticity of transformation (output), by convention these are denoted s and t respectively, although any identifier may be used. As a minimal example, [s=1, t=0] will set the s nest to have an elasticity of 1 and the t nest 0.\n\nAdditional nests must have a parent nest, which is defined by the => operator. For example, if you want a nest below s called va with an elasticity of 2, this is created with [s=1, t=0, va=>s=2]. The va points at its parent nest s and the elasticity follows. Nestings can be arbitrarily deep, for example\n\n[s=1, t=0, va=>s=2, dm=>s=1, d=>dm=2]\n\nwill have two nests, va and dm, below s and one below dm, namely d.\n\nNon-root nests can also be indexed. For example, if I=[:a,:b], we can created an indexed nest with [s=1, t=0, va[i=I]=>s=2]. This will create a nest va for each element of I with an elasticity of 2. \n\nFinally, elasticities can be either numbers, parameters, or a defined expression. For example, all of the following define nestings if the sectors and parameters are defined:\n\njulia> V = Dict(:a => 1, :b => 2)\n\njulia> I = [:a,:b]\n\njulia> J = [:c, :d]\n\njulia> @production(M, X, [s=1,t=0, va[i=I]=> s = V[i], ...)\n\njulia> @production(M, X[i=I], [s = V[i], t=0, va=>s=V[i]], ...)\n\njulia> @production(M, X[i=I], [s = 0, t=0, va[ii=I, j=J] => s = V[ii]],...)\n\nnetputs\n\nA netput is either an @input or an @output. The netputs get wrapped in a begin ... end block and each netput must be on its own line. For examples creating netputs, see the netput documentation and the examples below.\n\nNetputs can use indices initialized in the sector, but can not use them as a new index. For example, if we have X[i=I] in the production block, we can use @input(PX[i],...) but not @input(PX[i=I],...). The latter will error.\n\nExamples\n\nWe demonstrate three ways to define a production block. \n\njulia> M = MPSGEModel();\n\njulia> I = [:a,:b]\n\njulia> @parameters(M, begin\n            elas[i=I,j=J], 4\n            T[i=I], .1\n        end)\n\njulia> @sectors(M, begin\n            X\n            Y[i=I, j=J]\n            Z[i=I]\n        end);\n\njulia> @commodities(M, begin\n            PX\n            PY\n            PL[i=I]\n            PK\n        end);\n\njulia> @consumer(M, RA);\n\njulia> @production(M, X, [s=1,t=0], begin\n            @output(PX, 10, t)\n            @input(PL, 5, s)\n            @input(PK, 5, s)\n        end);\n\njulia> @production(M, Y[i=I,j=J], [s=2, t=1, va[ii=I]=>s=elas[i,ii]], begin\n            @output(PY, 15, t)\n            @input(PX, 3, s)\n            @input(PL[ii=I], 4, va[ii], taxes = [Tax(RA, .5)])\n            @input(PK, 6, va[i])\n        end);\n\njulia> for i in I\n            @production(M, Z[i], [s=1, t=0], begin\n                @output(PK, 20, t)\n                @input(PL[i], 2, s, taxes = [Tax(RA, T[i])])\n            end)\n        end\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@sector-Tuple","page":"API Reference","title":"MPSGE.@sector","text":"@sector(model, S, kwargs...)\n@sector(model, S[I], kwargs...)\n@sector(model, S[i=I], kwargs...)\n\nCreate a sector in the model with name S, index I, and index name i with arguments kwargs.\n\nArguments\n\nmodel: An instance of MPSGEModel.\nThe sector S can be instantiated in a several ways. \nS creates a scalar sector\nIf I is a defined array, then S[I] creates an indexed sector with \nindices given by I.\nIf I is a defined array, then S[i=I]creates an indexed sector with \nindices given by I and variable index named i. \n\nIf you want to create an index sector it is highly recommended to use the syntax  from (3) with better name for i, For example S[goods=I], this will set the  index name to goods which will be displayed when printing the model. For example creating a variable using\n\n@sector(M, S[goods=I], description = \"Sector with indexed variables\")\n\nwill allow the sector to be printed as\n\nS[goods] -- Sector with indexed variables\n\nAdditionally, multi-indexed sectors can be created by using the syntax  S[regions = R, goods = G]. \n\nOptional Arguments\n\ndescription: Set a description on a variable. \nstart: Set the starting value of the variable Default 1.0\nlower_bound: Set the lower bound of the variable. Default 0.\nupper_bound: Set the upper bound of the variable. Default Inf.\n\nExamples\n\nusing MPSGE\n\nR = Symbol.(:r, 1:5)\nG = Symbol.(:g, 1:5)\nM = MPSGEModel()\n\n@sector(M, S[region=R, goods=G], description=\"Sector with indexed variables\", start = 1.5)\n\n\n\n\n\n","category":"macro"},{"location":"docs/#MPSGE.@sectors-Tuple{Any, Any}","page":"API Reference","title":"MPSGE.@sectors","text":"@sectors(model, args...)\n\nAdds multiple @sector to a model. \n\nThe model must be the first argument, and multiple sectors can be added in a  begin ... end block, one sector per line. \n\nExample\n\njulia> M = MPSGEModel()\n\njulia> I = [:a,:b]\n\njulia> @sectors(M, begin\n            X[i=I]\n            Y[i=I,j=I], (description = \"This is an indexed variable\")\n            Z, (description = \"Scalar variable\")\n        end)\n\nnote: Note\nKeywords must be contained in parentheses as in the example above. \n\n\n\n\n\n","category":"macro"},{"location":"overview/production/#Production-Blocks","page":"Production Blocks","title":"Production Blocks","text":"Production blocks build cost functions. To build a cost function, we need to specify the inputs (costs) and outputs (revenues) of the production process. In MPSGE, production blocks are created using the @production macro. The documentation for the @production macro does a great job of explaining the syntax and options available when defining a production block, but there is a lot going on behind the scenes that is not immediately obvious. This section aims to clarify some of those details.","category":"section"},{"location":"overview/production/#Netputs","page":"Production Blocks","title":"Netputs","text":"A netput is general term for an @input or @output. A netput is a leaf in the production tree structure, acting as the initial information for building the cost functions. A netput stores the following information:\n\ncommodity: A commodity variable acting as the price.\nquantity: This acts more as a reference quantity. If the reference price is 1 this can be thought of as the total value exclusive of tax. This will be discussed below.\nparent: The nest that this netput belongs to.\nreference_price = 1: The price at the reference quantity, defaulting to 1.\ntaxes = []: A vector of taxes applied to this netput, defaulting to no taxes.\nnetput_sign: A value of -1 for inputs and 1 for outputs.\n\nThe \"cost function\" of a netput is the adjusted price. For example, if the commodity is P, the reference price is P_0, and there is are taxes tau_i, then the final price, barP, of the netput is given by:\n\nbarP  = fracPcdot(1 mp sum_i tau)P_0\n\nwhere the mp is determined by the netput_sign (use - for outputs and + for inputs). \n\nnote: $\\mp$ vs $\\pm$\nI've used mp here to indicate that the sign is opposite of the netput sign. This may change in the future, but will be documented clearly if it does.\n\nIf Q is the reference quantity, then the effective quantity, barQ, is given by:\n\nbarQ = Q cdot P_0\n\nUsing this, the total value at the benchmark point is given by:\n\nbarPcdot barQ = Pcdot Q cdot (1 mp sum_i tau)\n\nNotice that on the input side, the reference quantity should be exclusive of taxes, while on the output side, the reference quantity should be inclusive of taxes. The corresponding tax revenue is assigned to the consumer specified in the tax definition.","category":"section"},{"location":"overview/production/#Nests","page":"Production Blocks","title":"Nests","text":"The third argument to the @production macro is a list of nests with elasticities. These nests define a tree structure that describes how inputs/outputs are combined in the production process. \n\nThere must always be exactly two nests with no parents, which represent the top-level input and output nests. These are denoted nest_name = elasticity. By convention we use s for the input nest, short for elasticity of substitution and t for the output nest, short for elasticity of transformation. However, we are free to use any names we like for the nests. Top level nests are not allowed to be indexed, mathematically these are defining the roots of the input and output trees.\n\nLower-level nests are defined using the syntax child_nest => parent_nest = elasticity, which indicates that child_nest is a child of parent_nest with the specified elasticity. Child nests can be indexed, for example if goods can be obtained per region and each region has its own elasticity, you could define region_nest[r=region] => s = elasticity[r]. \n\nnote: Images\nThis section could use some images to illustrate the nest structure.\n\nnote: Nest Names\nNests have names given by the base name and index. However, it is currently not clear how to access nests by name. This will be updated soon.","category":"section"},{"location":"overview/production/#Nodes","page":"Production Blocks","title":"Nodes","text":"Nodes are not typically used by the end user, but they are important to understand how MPSGE builds cost functions. A node is an internal representation of a non-leaf vertex in the production tree. Each node stores the following information:\n\nmodel: A reference to the MPSGE model.\nparent: The parent node, defaults to nothing for the root nodes.\nchildren: A vector of child nodes or netputs.\ndata: A reference to the nest that defines the node\ncost_function_virtual: The variable representing the cost function at this node.\ncost_function: The cost function associated with the node.\nnetput_sign: A value of -1 for input nests and 1 for output nests.\n\nNodes are responsible for building and storing the cost functions. Cost functions are built recursively, the cost function for a node depends on the cost functions of its children. Cost functions can get large and may be repeated many times. Because of this, an optimization is performed where cost functions are stored as variables in the underlying JuMP model. This significantly reduces the size of the generated model and speeds up solving time as large expressions do not need to be re-evaluated.","category":"section"},{"location":"overview/production/#Building-Cost-Functions","page":"Production Blocks","title":"Building Cost Functions","text":"Cost functions are built recursively starting from the leaves of the production tree (the netputs) and working up to the root nodes. This process will best be described with an example. \n\nWe will focus on the input side, as the output side is analogous. Consider a production block with the following structure:\n\n          (s)\n         /   \\\n        /     \\\n(P_X, Q_X)    (P_Y, Q_Y)\n\nOr one top level nest s with two inputs X and Y. The cost functions for the two leaves are given above. Let Q_T = Q_X + Q_Y be the total reference quantity for the nest s. The CES cost function with elasticity sigmane1 for the top-level nest s is given by:\n\nbeginalign*\n  CF(s) =   Q_T cdot left( fracQ_XQ_Tcdot CF(X)^1-sigma + fracQ_YQ_Tcdot CF(Y)^1-sigma   right) ^ frac11-sigma \n   =  Q_T cdot left( fracQ_XQ_Tcdot (P_X)^1-sigma + fracQ_YQ_Tcdot (P_Y)^1-sigma   right) ^ frac11-sigma\nendalign*\n\nThis example generalizes to more complex nest structures by recursively applying the same logic. Each node computes its cost function based on the cost functions of its children, ultimately leading to the top-level cost functions for inputs and outputs.","category":"section"},{"location":"Tutorials/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"The purpose of these \"Getting Started\" tutorials is to teach new users the basics of Julia, JuMP, and MPSGE.","category":"section"},{"location":"Tutorials/introduction/#How-these-tutorials-are-structured","page":"Introduction","title":"How these tutorials are structured","text":"A high-level overview of the structure of this documentation will assist in finding relevant information.\n\nThe \"Getting Started With\" tutorials are designed as basic introductions to Julia, JuMP, and MPSGE. If you are new to Julia, JuMP, or MPSGE these are the places to start. For now, the non-MPSGE bullets point to JuMP documentation. \nGetting started with Julia\nGetting started with JuMP\nGetting started with sets and indexing\nGetting started with data and plotting\nDebugging Models\nTips for large models","category":"section"},{"location":"Tutorials/introduction/#Markusen's-Examples","page":"Introduction","title":"Markusen's Examples","text":"","category":"section"},{"location":"Tutorials/getting_started/first_example/#Getting-Started-with-MPSGE","page":"Getting Started with MPSGE","title":"Getting Started with MPSGE","text":"In this opening tutorial we will introduce the basics of MPSGE. We will start with a simple example and build from there.","category":"section"},{"location":"Tutorials/getting_started/first_example/#Statement-of-Problem","page":"Getting Started with MPSGE","title":"Statement of Problem","text":"We start with our data. The following table is related to a social accounting matrix, SAM, in that the row and columns both sum to zero.\n\nMarkets X Y W CONS\nPX 100  -100 \nPY  100 -100 \nPW   200 -200\nPL -25 -75  100\nPK -75 -25  100\n\nThere are two types of columns in this matrix, sectors (X, Y, W) and consumers (CONS). These take in and produce commodities (PX, PY, PW, PL, PK). For example, sector X produces 100 units of PX and consumes 25 units of PL and 75 units of PK. This is the justification for why each column sums to zero, the inputs and outputs are balanced. Technically, the consumer, CONS, does not \"produce\" anything, the consumer is demanding PW and endowing the market with PL and PK.\n\nThe commodities (PX, PY, PW, PL, PK) are represented in rows. For example, PX is produced in X and consumed in W. We assume all generated commodities get used, so the sum of the rows is zero.\n\nnote: Note\nWe've explicity used units in the discussion above. The values in the matrix   are prices times quantities, but interpreting them in this context makes   modelling more difficult. It is better to think of these as \"representative   quantities\" and then set initial prices to be 1. We will return to this dicsussion   later, but it's useful to keep in mind.\n\nIn this example we see PX and PY as the commodities produced by sectors X and Y respectively. PW is the commodity produced by sector W and represets welfare of the consumers, they want to consume PX and PY. PL and PK are the factors of production, labor and capital, respectively.","category":"section"},{"location":"Tutorials/getting_started/first_example/#Modeling-the-Problem","page":"Getting Started with MPSGE","title":"Modeling the Problem","text":"We will now define the model. We start by loading the MPSGE package and defining our model.\n\nusing MPSGE\n\nDefine the model\n\nM_basic = MPSGEModel()\n\nInitialize the @sectors, @commodities, and @consumer. We use the plural form of sectors and commodities as we have multiple of each, and the singular form of consumer as we only have one consumer.\n\n@sectors(M_basic, begin\n    X, (description = \"Sector X\")\n    Y\n    W\nend)\n\n@commodities(M_basic, begin\n    PX\n    PY\n    PW\n    PL\n    PK\nend)\n\n@consumer(M_basic, CONS)\n\nWe now define the production and demand relationships. We use the @production and @demand macros to define these relationships.\n\nIn this first example we will assume a Cobb-Douglass production function on the inputs of each sector. To do this we set the elasticity of substitution, s, to 1. Since each sector has only a single output the elasticity of transformation, t, is largely irrelevant, but we set it to zero.\n\nAt this point you should compare these values to the matrix above. The values in each block correspond to columns in the matrix.\n\n@production(M_basic, X, [s=1, t=0], begin\n    @output(PX, 100, t)\n    @input(PL, 25, s)\n    @input(PK, 75, s)\nend)\n\n@production(M_basic, Y, [s=1, t=0], begin\n    @output(PY, 100, t)\n    @input(PL, 75, s)\n    @input(PK, 25, s)\nend)\n\n@production(M_basic, W, [s=1, t=0], begin\n    @output(PW, 200, t)\n    @input(PX, 100, s)\n    @input(PY, 100, s)\nend)\n\n@demand(M_basic, CONS, begin\n    @final_demand(PW, 200)\n    @endowment(PL, 100)\n    @endowment(PK, 100)\nend)\n\nIn this simple model it can be useful to print the model to verify everything is as expected. This is not a standard step, but it can be useful for debugging.\n\nM_basic\n\nNow we solve the model. We use the solve! function to solve the model. The first solve is usually at the benchmark level, which means all values are as they appear in the table. This means the system should already be solved and we should see that reflected in the output, the residual should be zero (or close to it)\n\nsolve!(M_basic, cumulative_iteration_limit=0)\n\nThis model solves as expected. We can view the solution as a dataframe using the generate_report function.\n\ngenerate_report(M_basic)\n\nIf the model had not solved we would use this report to identify which marginal value was not zero and then adjust the model accordingly. The margin value is is a measure of how far the model is from solving in the given variable.\n\nThe last line of the report shows what variable and value was selected as numeraire. In this case it was CONS with a value of 200. If no varaibles are fixed before solve, the largest consumer is selected as the numeraire. To set a different numeraire use the fix function to set the value of a variable.\n\nYou can access the values of the variables directly. For example, to get the value of PX you can use the following code.\n\nvalue(PX)\n\nIf you have multiple models, or your model is created in a function, you can also access variables using the model. For example, to get the value of PX in the M_basic model you can use the following code.\n\nvalue(M_basic[:PX])","category":"section"},{"location":"Tutorials/getting_started/first_example/#Expanding-the-Model","page":"Getting Started with MPSGE","title":"Expanding the Model","text":"The model M_basic is a simple model that demonstrates the basic structure of an MPSGE model. However, it is not a very interesting model, all it does is represent the data in the table. We can't change anything or ask questions, like what happens if we impose a tax on labor PL or capital PK?\n\nLet's expand the model to include taxes on labor and capital. To do this we write a new model and introduce some parameters.\n\nM_tax = MPSGEModel()\n\nWe introduce two parameters, labor_tax and capital_tax. These will be used to set the tax rates on labor and capital. We set the default values to zero, but we can change these values later.\n\n@parameters(M_tax, begin\n    labor_tax, 0\n    capital_tax, 0\nend)\n\n@sectors(M_tax, begin\n    X, (description = \"Sector X\")\n    Y\n    W\nend)\n\n@commodities(M_tax, begin\n    PX\n    PY\n    PW\n    PL\n    PK\nend)\n\n@consumer(M_tax, CONS)\n\nWe are going to impose the labor and capital taxes on the production of X. We do this by adding the taxes to the inputs of X. Taxes need a consumer, to collect the tax, and a tax rate. You can add taxes to either inputs or outputs, but in this case we are adding them to the inputs.\n\n@production(M_tax, X, [s=1, t=0], begin\n    @output(PX, 100, t)\n    @input(PL, 25, s, taxes = [Tax(CONS, labor_tax)])\n    @input(PK, 75, s, taxes = [Tax(CONS, capital_tax)])\nend)\n\n@production(M_tax, Y, [s=1, t=0], begin\n    @output(PY, 100, t)\n    @input(PL, 75, s)\n    @input(PK, 25, s)\nend)\n\n@production(M_tax, W, [s=1, t=0], begin\n    @output(PW, 200, t)\n    @input(PX, 100, s)\n    @input(PY, 100, s)\nend)\n\n@demand(M_tax, CONS, begin\n    @final_demand(PW, 200)\n    @endowment(PL, 100)\n    @endowment(PK, 100)\nend)\n\nFirst, we check the model at the benchmark level. This is to ensure we've entered our data correctly. We will also fix the numeraire to be PW and set the value to 1. This is not necessary, but it in this case it makes the results easier to interpret as it is the only welfare price variable.\n\nfix(PW, 1)\n\nsolve!(M_tax, cumulative_iteration_limit=0)\n\nLet's impose a 10% tax on labor. We do this by setting the value of labor_tax to 0.1 and then solving the model. Notice we do not set the cumulative iteration limit to zero, this is because we are not at the benchmark level. Feel free to try, you'll see what an unbalanced model looks like.\n\nset_value!(labor_tax, 0.1)\n\nsolve!(M_tax)\n\nWe see the solver output has changed. The residual should be, essentially, zero and the solve has gone through a few iterations. Let's generate a report to see the results.\n\ngenerate_report(M_tax)\n\nvalue(PL/PW)\n\nWe see some interesting information in this model. The real wage PL/PW has declined by 2.3% (from 1 to .976), while the return to capital, PK (in real terms) is, essentially, unchanged. The price of Y (the labor-intensive good) decreases because the tax is applied on the other sector.  The price of the capital-intensive good, X, increases because it is taxed while the other good is not.\"\n\nWhat does this really mean? What impact does have on the welfare of the consumer? We can answer this question by calculating the welfare index of the consumer. This is the consumer value divided by the price of welfare, PW. We'll store this value in a variable, labor_tax_welfare for later use.\n\nlabor_tax_welfare = value(CONS/PW)\n\nWhat we see is that the overall welfare of the consumer has decreased, the base line was 200 and now it's 199.916. This makes intuitive sense, an imposed tax increases the cost of production, which is passed on to the consumer.\n\nNow let's impose a 10% tax on capital. To do this we reset the value of labor_tax to zero and set the value of capital_tax to 0.1. We then solve the model and generate a report.\n\nset_value!(labor_tax, 0.0)\nset_value!(capital_tax, 0.1)\n\nsolve!(M_tax)\n\ngenerate_report(M_tax)\n\nAgain, let's calculate the welfare index of the consumer.\n\ncapital_tax_welfare = value(CONS/PW)\n\nSubtracting, it appears the labor_tax is less harmful to the consumer than the capital_tax.\n\nlabor_tax_welfare - capital_tax_welfare","category":"section"},{"location":"Tutorials/getting_started/first_example/#Plotting-Welfare","page":"Getting Started with MPSGE","title":"Plotting Welfare","text":"Let's make a graph comparing the welfare of the consumer under different tax rates. We'll use the PlotlyJS and DataFrames packages.\n\nusing PlotlyJS, DataFrames\nusing PlotlyDocumenter # hide\n\nWe'll be solving about 100 models, so we'll suppress the output.\n\nset_silent(M_tax)\n\nThe idea is to initialize a DataFrame and then loop over a range of tax rates.\n\ndf = DataFrame()\nfor i in 0:.01:.5\n    set_value!(labor_tax, i)\n    set_value!(capital_tax, 0)\n    solve!(M_tax)\n    push!(df, (tax_value = i, type = :labor, welfare = value(CONS/PW)))\n\n    set_value!(labor_tax, 0)\n    set_value!(capital_tax, i)\n    solve!(M_tax)\n    push!(df, (tax_value = i, type = :capital, welfare = value(CONS/PW)))\nend\n\np = plot(df, x=:tax_value, y=:welfare, color=:type,\n    Layout(title= \"Labor vs Capital tax rates\")\n)\n\nto_documenter(p) # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_rc/#One-Consumer,-One-Producer,-Two-Goods","page":"One Consumer, One Producer, Two Goods","title":"One Consumer, One Producer, Two Goods","text":"","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_rc/#Model-Definition","page":"One Consumer, One Producer, Two Goods","title":"Model Definition","text":"In this economy, Robinson Crusoe acts as both a producer and consumer of coconuts and fish. To disambiguate between the producer and consumer, we will refer to the producer as rc_producer and the consumer as rc_consumer.\n\nThere are three commodities: coconuts, fish and labor. We will call these variables price_coconuts, price_fish and price_labor. rc_producer takes in price_labor and outputs both price_fish and price_coconuts. Conversely, rc_consumer demands both price_fish and price_coconuts and endows the market with price_labor.\n\nAt this point we can initialize our model. The first step is load the MPSGE package and initialize our model.\n\nusing MPSGE\n\nM = MPSGEModel()\n\nNext we define our @sector, @commodities, and @consumer. Notice the use of singular and plural, we are using the singular @sector since we only have one sector. We could have three @commodity(M, price_X) statements rather than the single @commodities using the plural is less typing.\n\nThe last line prints the model. This is not a standard or necessary step. But it's useful to verify our variables have been added to the model.\n\n@sector(M, rc_producer)\n\n@commodities(M, begin\n    price_coconuts\n    price_fish\n    price_labor\nend)\n\n@consumer(M, rc_consumer)\n\nprint(M)\n\nSimilar to JuMP, these macros put each variable name into the local scope. That means we can use price_coconuts rather than extracting from the model, e.g. M[:price_coconuts].\n\nThe code below works, but isn't interesting. It's just demonstrating that price_coconuts is in the local namespace.\n\nprice_coconuts\n\nA @production block defines the inputs and outputs from a sector. Recall we said\n\n  `rc_producer` takes in `price_labor` and outputs both `price_fish` and\n  `price_coconuts`\n\nThis tells us the inputs and outputs. For the moment we are going to set all quantities to one. We will have examples later that deal with balanced data.\n\nThe code [s=0,t=0] defines the elasticity of substitution and the elasticity transformation. By convention these are denoted s and t, but that is not a requirement any name is sufficient. Future examples will show a far more complex nesting structure.\n\n@production(M, rc_producer, [s=0, t=0], begin\n    @output(price_coconuts, 1, t)\n    @output(price_fish, 1, t)\n    @input(price_labor, 1, s)\nend)\n\nWe define the demands in a @demand block. This resembles a production block with no elasticities.\n\n@demand(M, rc_consumer, begin\n    @final_demand(price_coconuts, 1)\n    @final_demand(price_fish, 1)\n    @endowment(price_labor, 1)\nend)\n\nWe are going to set price_coconuts as the numeraire and fix it's value to 1. This is not a necessary step, if there is no numeraire MPSGE will set fix the value of the largest consumer as the numeraire, this is reported to the user when the model is solved.\n\nfix(price_coconuts, 1)\n\nFinally we solve the model and generate a report.\n\nsolve!(M)\n\ngenerate_report(M)\n\nResults can also be extracted using value. Most JuMP features have been extended to work on MPSGE variables.\n\nvalue(price_fish)\n\nDiscuss the results of the model","category":"section"},{"location":"Tutorials/robinson_crusoe/basic_rc/#Extracting-Model-Equations","page":"One Consumer, One Producer, Two Goods","title":"Extracting Model Equations","text":"There isn't much else we can do with this model, there are no parameters so we can't modify values and re-solve. However, in this simple model we can explore the equations and model structure.\n\nWe can extract production blocks to ensure they were input correctly. This view uses a syntax similar to MPSGE.GAMS, but should be readable.\n\nproduction(rc_producer)\n\nThere are three types of constraints in a MPSGE model, zero_profit, market_clearance, and income_balance. We can extract each of these.\n\nZero profit takes in a sector:\n\nMPSGE.zero_profit(rc_producer)\n\nMarket clearance takes a commodity:\n\nMPSGE.market_clearance(price_coconuts)\n\nAnd income balance takes a consumer:\n\nMPSGE.income_balance(rc_consumer)\n\nWe can extract the market clearing conditions for all the commodities using broadcasting.\n\nMPSGE.market_clearance.(commodities(M))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"how_it_works/#How-MPSGE-Works","page":"How MPSGE Works","title":"How MPSGE Works","text":"Work in progress – This explanation is quick and dirty. A more fully featured explanation is in progress.","category":"section"},{"location":"how_it_works/#Constructing-Equations","page":"How MPSGE Works","title":"Constructing Equations","text":"Consider a production block on sector S. This block will have an input tree and output tree. The generated equations are different for inputs vs outputs.  However, they only differ up to a sign in certain locations. Let \n\nepsilon = leftbeginarraycl\n    -1  textTree is input \n     1  textTree is output\nendarrayright\n\nrepresent this sign. ","category":"section"},{"location":"how_it_works/#Compensated-Demand","page":"How MPSGE Works","title":"Compensated Demand","text":"Consider a netput tree containing a single nest and k children, either commodities or  nests, as in the Figure below. \n\n(Image: \"one_level_tree\")\n\nEach child node has a quantity q_i. Each commodity node has a reference price p_i,  base quantity Q_i, reference quantity q_i=p_icdot Q_i, variable C_i,  and taxes t_ih, where the index h is a consumer. Then q = sum q_i  is the quantity of the root n. The root also has an elasticity sigma.\n\nThe cost function for a commodity node n_i will be given by pi(nC_i) where\n\npi(nC_i) = fracC_i(1-epsilonsum_h t_ih)p_i\n\nThis must be indexed by both the parent nest and commodity as commodities can appear in a netput tree multiple times, albeit not directly under the same nest. The cost function for any non-commodity child node is defined recursively in this manner. This is well defined as all leaves are commodities.\n\nThe cost function on the root n, C(n), depends on the elasticity of the root. If sigma=1, the cost function is given by Cobb-Douglass\n\n  C(n) =  prod_i=1^k pi(nC_i)^fracq_iq\n\nAnd if sigmane1 then we use a CES cost function\n\nC(n) = \n        left(sum_i=1^k fracq_iq pi(nC_i)^1+epsilonsigmaright)^frac11+epsilonsigma\n\nIn general, these trees can be highly nested. Consider a path from the root, n_1 to a leaf n_k+1. Using this we can calculate the compensated demand, CD(SCn_k), for the sector S, commodity C and nest n_k\n\nCD(SCn_k) = -epsilon Q_C left(fracC(n_k)pi(n_kC)right)^-epsilonsigma_k prod_i=1^k-1 left(fracC(n_i)C(n_i+1)right)^-epsilonsigma_i\n\nFinally, the compensated demand, CD(SC), is the summation over all nests that have C as a leaf.\n\nCD(SC) = sum_substackntext nest textif (nC)text is an edge CD(SCn)\n\nFor convenience we take any compensated demand not defined above to be 0, this follows from the empty summation in CD(SC).","category":"section"},{"location":"how_it_works/#\\tau","page":"How MPSGE Works","title":"tau","text":"For sector S and consumer H define \n\ntau(SH) = - sum_substackCintext Commoditiesnintext nests CD(SCn)cdot t_SCHncdot C\n\nwhere t_SCHn is the tax on the commodity C by consumer H in sector S  under nest n.","category":"section"},{"location":"how_it_works/#Endowments/Demands","page":"How MPSGE Works","title":"Endowments/Demands","text":"For commodity C and consumer H define E(HC) to be the endowment quantity. This is taken to be 0 if there is no endowment for H and C.\n\nLet sigma be the elasticity of demand, q_C be the quantity of demand for commodity C in H consumer demand, q = sum_C q_C be the total demand, and p_C be the reference price of the commodity. Define the demand function, D(HC), as\n\nD(HC) = fracq_Cqcdot fracHCcdot leftbeginarrayccfracp_Hcdottextexpenditure(H)C^sigma-1  sigmane1  1  textotherwise endarrayright\n\nwhere\n\ntextexpenditure(H) = left(sum_Cintext demands(H) fracq_Ccdot Cqcdot p_Cright)^1(1-sigma)","category":"section"},{"location":"how_it_works/#Constraints","page":"How MPSGE Works","title":"Constraints","text":"With these definitions, we can define the complementarity constraints. ","category":"section"},{"location":"how_it_works/#Zero-Profit","page":"How MPSGE Works","title":"Zero Profit","text":"Let S be a sector with a production block, then the zero profit condition is  given by,\n\nleft(sum_Cintext CommoditiesCD(SC)cdot Cright) - sum_Hintext Consumers tau(SH) perp S","category":"section"},{"location":"how_it_works/#Market-Clearance","page":"How MPSGE Works","title":"Market Clearance","text":"Let C be a commodity, then the market clearance condition is given by,\n\nleft(sum_Sintext Sectors CD(SC)cdot S right) - sum_Hintext Consumers E(HC) - D(HC) perp C","category":"section"},{"location":"how_it_works/#Income-Balance","page":"How MPSGE Works","title":"Income Balance","text":"Let H be a consumer, then the income balance condition is given by,\n\nH - left(sum_Cintext Commodities E(HC)cdot C - sum_Sintext Sectorstau(SH)cdot Sright) perp H","category":"section"},{"location":"cookbook/main/#Cookbook","page":"Cookbook","title":"Cookbook","text":"","category":"section"},{"location":"Tutorials/intermediate_examples/m22/#Closed-2\\times2-Economy-with-Intermediate-Inputs-and-Nesting","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Closed 2times2 Economy with Intermediate Inputs and Nesting","text":"Consider the following social accounting matrix (SAM).\n\nMarkets X Y W CONS\nPX 120 -20 -100 \nPY -20 120 -100 \nPW   200 -200\nPL -40 -60  100\nPK -60 -40  100\n\nWe are going to use this matrix to construct a simple CES nesting structure that permits the modeler to specify different elasticities of substitution between different groups of inputs.\n\nWhile the SAM contains the data to build the model, it doesn't specify any structure. To do this we use a tree diagram. For this model we will have four trees: X, Y, W, CONS.\n\n(Image: Specific Model Description)\n\nThese should be self explanatory, but we'll detail the X tree. First, X has an associated elasticity of substitution s=sigma and elasticity of substitution t=0. There is only one output, PX with quantity 120. PY, PL, and PK are inputs, but we are nesting PL and PK under the shadow sector va, this is also referred to as a nest. The va=1 specifies the elasticity of substitution on the inputs of va. Finally, we are going to impose a tax on PL and PK, taxes require a consumer in this case there is only one, CONS.\n\nThe CONS tree is similar, consumers have demands and endowments. In this case, CONS demands 200 units of PW and endows both PL and PK 100 units.\n\nUsing this type of diagram trivializes the implementation of a model into MPSGE. The language of MPSGE is directly tied to these trees, as we will see.","category":"section"},{"location":"Tutorials/intermediate_examples/m22/#Model-Initialization","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Model Initialization","text":"First we import MPSGE and initialize the model.\n\nusing MPSGE\n\nM = MPSGEModel()","category":"section"},{"location":"Tutorials/intermediate_examples/m22/#Defining-Variables","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Defining Variables","text":"This model has:\n\nThree sectors X, Y, and W\nFive commodities PX, PY, PW, PL, and PK\nOne consumer CONS\n\nLet's add these to the model.\n\n@sectors(M, begin\n    X\n    Y\n    W\nend)\n\n@commodities(M, begin\n    PX\n    PY\n    PW\n    PL\n    PK\nend)\n\n@consumer(M, CONS)\n\nWe use the plural version of both sector and commodity because we have multiple of each. Each of these variables has been added to the local namespace, so we can type X and it will display X. This is useful as we continue to build the model. These can also be accessed directly from the model, M[:X].","category":"section"},{"location":"Tutorials/intermediate_examples/m22/#Parameters","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Parameters","text":"In this model we will want a two parameters, tax and σ. This will allow us to apply various shocks without recompiling the model.\n\n@parameters(M, begin\n    tax, 0\n    σ, .5\nend)\n\nThe parameter block requires that you set initial values for each parameter.","category":"section"},{"location":"Tutorials/intermediate_examples/m22/#Production","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Production","text":"In this model we will have three production blocks, one for each sector. View the full @production documentation.\n\nWe'll detail the X production block as it has the most interesting structure. Here is the full production block,\n\n@production(M, X, [s = σ, t = 0, va => s = 1], begin\n    @output(PX, 120, t)\n    @input( PY, 20,  s)\n    @input( PL, 40,  va, taxes = [Tax(CONS,tax)])\n    @input( PK, 60,  va, taxes = [Tax(CONS,tax)])\nend)\n\nthere is a lot going on in this, let's break it down piece by piece. The first few pieces, @production(M, X, are self-explanatory, model and sector.\n\nThis brings us to [s = σ, t = 0, va => s = 1] which defines the nesting structure. There are two top level nests s and t with respective elasticities of σ and 0. Compare this to the other nest, va, which sits under s, this is denoted with va => s and the = 1 sets the elasticity to 1. One thing to notice is that σ is a previously defined parameter. In general, any quantity can be either a number or parameter.\n\nFinally, @input and @output. These must be wrapped in the begin .. end syntax. The syntax of building an output is the same as an input, so we'll describe an output. The required information is a commodity, quantity, and nest. We have used Julia macro syntax to suppress parentheses and commas, but you could equivalently defined these as\n\n@output(PX, 120, t)\n\nOutputs have two possible keywords, reference_price and taxes. reference_price is a simple quantity whereas taxes is an array of Tax objects, as illustrated in the PK input.\n\nThe remaining production blocks are similar,\n\n@production(M, Y, [t = 0, s = .75, va => s = 1], begin\n    @output( PY, 120, t)\n    @input(  PX, 20, s)\n    @input(  PL, 60, va)\n    @input(  PK, 40, va)\nend)\n\n@production(M, W, [t = 0, s = 1], begin\n    @output( PW, 200, t)\n    @input(  PX, 100, s)\n    @input(  PY, 100, s)\nend)","category":"section"},{"location":"Tutorials/intermediate_examples/m22/#Demand","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Demand","text":"Each consumer will have a corresponding demand block. Here is the demand block for CONS\n\n@demand(M, CONS, begin\n    @final_demand(PW, 200)\n    @endowment(PL, 100)\n    @endowment(PK,100)\nend)\n\nThe first two inputs are the model and the consumer. Then there are two begin .. end blocks, the first is for final demand and the second is endowments. This may get improved in the future to be a single block.","category":"section"},{"location":"Tutorials/intermediate_examples/m22/#Solving-the-Model","page":"Closed 2times2 Economy with Intermediate Inputs and Nesting","title":"Solving the Model","text":"To solve the model, you call solve! on the model. You can also pass PATH options view keyword arguments. In this case we are testing the benchmark calibration so we set the cumulative iteration limit to 0.\n\nsolve!(M; cumulative_iteration_limit = 0)\n\nWhile the solver output can be useful, it's more useful to see the values and the marginal values. Any non-zero marginal value should be investigated. LINK TO MODEL DEBUGGING INFORMATION HERE.\n\ndf_benchmark = generate_report(M)\n\nThis will return a Julia dataframe, which you can manipulate using any dataframe technique. If you plan to manipulate this dataframe, it will be useful to use the DataFrames package\n\nusing DataFrames\n\nYou can also retrieve information using standard JuMP functions, for example\n\nvalue(X)\n\nwill give you the value of X.\n\nWe can solve a counterfactual by changing the value of a parameter. In this case we'll also fix PW to 1 to pin a specific solution.\n\nfix(PW,1)\nset_value!(tax,.5)\n\nsolve!(M)\ndf = generate_report(M)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#[MPSGE](https://github.com/julia-mpsge/MPSGE.jl)","page":"MPSGE","title":"MPSGE","text":"","category":"section"},{"location":"#What-is-MPSGE?","page":"MPSGE","title":"What is MPSGE?","text":"MPSGE is a high level language for creating computable general equilibrium (CGE) models. Originally implemented in FORTRAN and made available as a subsystem in GAMS. The MPSGE documentation provided by GAMS is a useful reference, especially for background, theory, and some understanding of the included features.","category":"section"},{"location":"#Resources-for-getting-started","page":"MPSGE","title":"Resources for getting started","text":"JuMP","category":"section"},{"location":"#How-the-documentation-is-structured","page":"MPSGE","title":"How the documentation is structured","text":"note: Note\nThis documentation is under active development. \n\nTutorials: Written for new users of MPSGE. Walks through the MPSGE modelling process step-by-step. \nMathematical Background: MPSGE hides most of it's computation, this page describes precisely how MPSGE works.\nAPI Reference: A complete list of the functions MPSGE makes available. This is the same information you get in the help entry for individual functions.","category":"section"},{"location":"#Citing-MPSGE","page":"MPSGE","title":"Citing MPSGE","text":"A paper is being prepared. In the meantime reach out to the authors of the package for information.","category":"section"},{"location":"#License","page":"MPSGE","title":"License","text":"","category":"section"}]
}
